package no.entur.abt.bob.mts7.reader;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Random;

import com.fasterxml.jackson.dataformat.cbor.databind.CBORMapper;

import no.entur.abt.bob.mts7.api.Mts7Exception;
import no.entur.abt.bob.mts7.api.UnableToSelectApplicationException;
import no.entur.abt.bob.mts7.api.UnexpectedCardResponseException;
import no.entur.abt.bob.mts7.api.apdu.ResponseAPDU;
import no.entur.abt.bob.mts7.reader.processor.CBORExtractor;
import no.entur.abt.bob.mts7.reader.processor.Mts7Processor;
import no.entur.abt.bob.mts7.simple.api.Mts7ApduExchanges;
import no.entur.abt.bob.mts7.simple.reader.DefaultMts7Exchange;
import no.entur.abt.bob.mts7.simple.reader.Mts7ApduExchangesFactory;
import no.entur.abt.bob.mts7.simple.reader.Mts7Exchange;

/**
 * 
 * Card factory which does minimal work to gather the card data while also feeding an underlying processor.
 *
 */

public class ProcessorMts7ApduExchangesFactory extends Mts7ApduExchangesFactory {

	private static final int PARSE_TIMEOUT = 1000;

	protected final long timeout = PARSE_TIMEOUT;

	protected CBORExtractor algorithmExtractor = new CBORExtractor(new CBORMapper());

	public ProcessorMts7ApduExchangesFactory() {
		super();
	}

	public ProcessorMts7ApduExchangesFactory(Random random) {
		super(random);
	}

	public Mts7ApduExchanges create(Mts7Exchange mts7Exchange, Mts7Processor processor, byte[] selectApplicationResponse)
			throws IOException, Mts7Exception, InterruptedException {
		DefaultMts7Exchange result = new DefaultMts7Exchange(mts7Exchange);

		handleSelectApplication(mts7Exchange, processor, selectApplicationResponse);

		handleGetNextData(mts7Exchange, processor);

		handleInternalAuthenticate(mts7Exchange, processor);

		return result;
	}

	protected void handleSelectApplication(Mts7Exchange mts7Exchange, Mts7Processor processor, byte[] selectApplicationResponse)
			throws UnableToSelectApplicationException, IOException {
		if (selectApplicationResponse == null) {
			selectApplicationResponse = mts7Exchange.transceive(SELECT_BOB_COMMAND); // File Control Information (FCI) Template
		}

		if (!isSuccess(selectApplicationResponse)) {
			throw new UnableToSelectApplicationException(SELECT_BOB_COMMAND, selectApplicationResponse);
		}

		processor.onSelectApplicationResponseApdu(selectApplicationResponse);
	}

	protected void handleInternalAuthenticate(Mts7Exchange mts7Exchange, Mts7Processor processor) throws IOException, UnexpectedCardResponseException {

		byte[] payload = new byte[32]; // random bytes, i.e. same as SHA-256
		random.nextBytes(payload);

		// TODO happy go lucky EC card

		// 4.1.4. INTERNAL AUTHENTICATE
		// The INTERNAL AUTHENTICATE command is used to authenticate the PICC to the terminal using the
		// cardholder private key.
		// The Authentication Input to INTERNAL AUTHENTICATE is generated by the terminal and SHALL be
		// a SHA-256 hash. Appendix B outlines an example of a JSON object containing appropriate
		// information.
		// • For ECDSA-capable PICCs the hash value is used as Authentication Input,
		// • For PICCs relying on RSA the Travel card application MUST pad the Authentication Input to
		// the length of the modulus in accordance with PKCS#1 version 1.5. The Travel card application
		// MUST also verify the Authentication Input is in compliance with PKCS#1 provisions or
		// otherwise reject the operation.

		byte[] command = new byte[INTERNAL_AUTHENTICATE_COMMAND_PREFIX.length + payload.length + INTERNAL_AUTHENTICATE_COMMAND_POSTFIX.length];

		System.arraycopy(INTERNAL_AUTHENTICATE_COMMAND_PREFIX, 0, command, 0, INTERNAL_AUTHENTICATE_COMMAND_PREFIX.length);
		System.arraycopy(payload, 0, command, INTERNAL_AUTHENTICATE_COMMAND_PREFIX.length, payload.length);
		System.arraycopy(INTERNAL_AUTHENTICATE_COMMAND_POSTFIX, 0, command, INTERNAL_AUTHENTICATE_COMMAND_PREFIX.length + payload.length,
				INTERNAL_AUTHENTICATE_COMMAND_POSTFIX.length);

		byte[] internalAuthenticateResponse = mts7Exchange.transceive(command); // File Control Information (FCI) Template
		if (!ResponseAPDU.isSuccess(internalAuthenticateResponse)) {
			throw new UnexpectedCardResponseException(command, internalAuthenticateResponse);
		}

		byte[] data = new byte[internalAuthenticateResponse.length - 2];
		System.arraycopy(internalAuthenticateResponse, 0, data, 0, data.length);

		processor.onInternalAuthenticate(payload, data);

	}

	protected void handleGetNextData(Mts7Exchange mts7Exchange, Mts7Processor processor) throws IOException, UnexpectedCardResponseException {
		byte[] getNextDataResponse = mts7Exchange.transceive(GET_NEXT_DATA_COMMAND); // File Control Information (FCI) Template

		/*
		 * 4.1.3. GET RESPONSE If the status bytes from a GET DATA command is 61xx then there are more bytes to read than what is in the buffer. The remainder
		 * can be retrieved using GET RESPONSE
		 */

		if (isContinue(getNextDataResponse)) {
			ByteArrayOutputStream bout = new ByteArrayOutputStream();
			bout.write(getNextDataResponse, 0, getNextDataResponse.length - 2);

			do {
				byte[] getResponeRespone = mts7Exchange.transceive(GET_RESPONSE_COMMAND);
				if (!isContinue(getResponeRespone)) {
					bout.write(getResponeRespone); // i.e. including status code
					break;
				}

				// save payload only
				bout.write(getResponeRespone, 0, getResponeRespone.length - 2);
			} while (true);

			getNextDataResponse = bout.toByteArray();
		}

		if (!ResponseAPDU.isSuccess(getNextDataResponse)) {
			throw new UnexpectedCardResponseException(GET_NEXT_DATA_COMMAND, getNextDataResponse);
		}

		byte[] mtb = new byte[getNextDataResponse.length - 2];
		System.arraycopy(getNextDataResponse, 0, mtb, 0, mtb.length);

		processor.onGetData(mtb);
	}

}
