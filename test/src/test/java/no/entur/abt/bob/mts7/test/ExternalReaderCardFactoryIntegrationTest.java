package no.entur.abt.bob.mts7.test;

import java.io.ByteArrayOutputStream;

import org.junit.jupiter.api.Test;

import no.entur.abt.bob.mts7.test.record.bob.Mts7PrettyPrinterCard;
import no.entur.abt.bob.mts7.utils.ByteArrayHexStringConverter;
import no.entur.tlv.utils.TlvPrettyPrinter;

public class ExternalReaderCardFactoryIntegrationTest {

	public static final byte[] SELECT_BOB_COMMAND = new byte[] { 0x00, (byte) 0xA4, 0x04, 0x00, 0x06, (byte) 0xA0, 0x00, 0x00, 0x07, (byte) 0x81, 0x01 };
	public static final byte[] GET_DATA_COMMAND = new byte[] { 0x00, (byte) 0xCA, 0x7F, 0x21, 0x00, 0x00, 0x00 };
	public static final byte[] GET_NEXT_DATA_COMMAND = new byte[] { 0x00, (byte) 0xCC, 0x7F, 0x21, 0x00, 0x00, 0x00 };
	public static final byte[] INTERNAL_AUTHENTICATE_COMMAND_PREFIX = new byte[] { 0x00, (byte) 0x88, 0x00, 0x00, 0x20 };
	public static final byte[] INTERNAL_AUTHENTICATE_COMMAND_POSTFIX = new byte[] { 0x00, 0x00 };

	@Test
	public void testConnect() throws Exception {
		ExternalReaderCardFactory factory = new ExternalReaderCardFactory();

		TlvPrettyPrinter tlvPrettyPrinter = TlvPrettyPrinter.newBuilder().build();

		try (ExternalReaderCard card = factory.createCard(10000)) {
			System.out.println("Got card " + card);

			Mts7PrettyPrinterCard tlvPrinterCard = Mts7PrettyPrinterCard.newBuilder().withCard(card).withPrettyPrinter(tlvPrettyPrinter).build();

			byte[] ppseResponse = tlvPrinterCard.transceive(SELECT_BOB_COMMAND); // File Control Information (FCI) Template
			if (!isSuccess(ppseResponse)) {
				throw new Exception("Card responded with " + ByteArrayHexStringConverter.toHexString(ppseResponse));
			}

			/**
			 * 4.1.3. GET RESPONSE If the status bytes from a GET DATA command is 61xx then there are more bytes to read than what is in the buffer. The
			 * remainder can be retrieved using GET RESPONSE
			 */

			byte[] getNextDataResponse = tlvPrinterCard.transceive(GET_NEXT_DATA_COMMAND); // File Control Information (FCI) Template
			if (!isSuccess(getNextDataResponse)) {
				throw new Exception("Card responded with " + ByteArrayHexStringConverter.toHexString(getNextDataResponse));
			}

			ByteArrayOutputStream bout = new ByteArrayOutputStream(128);
			bout.write(INTERNAL_AUTHENTICATE_COMMAND_PREFIX);

			byte[] payload = new byte[32];
			bout.write(payload);
			bout.write(INTERNAL_AUTHENTICATE_COMMAND_POSTFIX);

			// 4.1.4. INTERNAL AUTHENTICATE
			// The INTERNAL AUTHENTICATE command is used to authenticate the PICC to the terminal using the
			// cardholder private key.
			// The Authentication Input to INTERNAL AUTHENTICATE is generated by the terminal and SHALL be
			// a SHA-256 hash. Appendix B outlines an example of a JSON object containing appropriate
			// information.
			// • For ECDSA-capable PICCs the hash value is used as Authentication Input,
			// • For PICCs relying on RSA the Travel card application MUST pad the Authentication Input to
			// the length of the modulus in accordance with PKCS#1 version 1.5. The Travel card application
			// MUST also verify the Authentication Input is in compliance with PKCS#1 provisions or
			// otherwise reject the operation.

			byte[] internalAuthenticateResponse = tlvPrinterCard.transceive(bout.toByteArray()); // File Control Information (FCI) Template
			if (!isSuccess(internalAuthenticateResponse)) {
				throw new Exception("Card responded with " + ByteArrayHexStringConverter.toHexString(getNextDataResponse));
			}

			// The response SHALL contain the result of the signing operation:
			// • For ECDSA-capable PICCs the response is the two vectors r and s encoded in a string of
			// octets with big-endian order, each prefixed with zeroes to match the maximum length,
			// concatenated together.
			// • For PICCs relying on RSA the response is the result of xd (mod n) encoded in a string of
			// octets with big-endian order prefixed with zeroes to the length of the modulo.
		}
	}

	public static boolean isSuccess(byte[] response) {
		return response.length >= 2 && (response[response.length - 2] & 0xFF) == 0x90 && (response[response.length - 1] & 0xFF) == 0x00;
	}

}
